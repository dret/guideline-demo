<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Axway API Guideline Generator</title><style>
ol { counter-reset: item }
li { display: block }
li:before { content: counters(item, ".") " "; counter-increment: item }
.accordion { background-color: #eee; color: #444; cursor: pointer; padding: 18px; width: 100%; border: none; text-align: left; outline: none; font-size: 15px; transition: 0.4s; }
.active, .accordion:hover { background-color: #ccc; }
.panel { padding: 0 18px; background-color: white; max-height: 0; overflow: hidden; transition: max-height 0.2s ease-out; }
          </style></head>
   <body>
      <h1>Axway API Guideline Generator</h1>
      <ol><button class="accordion" title="APIs should be using the API style that best matches their service and consumers">API Style</button><div class="panel">
            <p>
               <text>
                  <p></p>
               </text>
            </p><button class="accordion" title="Remote Procedure Call (RPC)">Query Style</button><div class="panel">
               <p>
                  <text>
                     <p></p>
                  </text>
               </p><button class="accordion" title="GraphQL">GraphQL</button><div class="panel">
                  <p>
                     <text>
                        <p></p>
                     </text>
                  </p>
               </div>
            </div><button class="accordion" title="Remote Procedure Call (RPC)">RPC Style</button><div class="panel">
               <p>
                  <text>
                     <p></p>
                  </text>
               </p><button class="accordion" title="Simple Object Access Protocol (SOAP)">SOAP</button><div class="panel">
                  <p>
                     <text>
                        <p></p>
                     </text>
                  </p>
               </div>
            </div>
         </div><button class="accordion" title="APIs should be explicit about how changes to the API are managed and communicated.">Change Management Policy</button><div class="panel">
            <p>
               <text>
                  <p>One of the typical goals of APIs is to cleanly and clearly decouple how a capability
                     is provided, and how it is consumed. The API becomes the only interface that exists
                     between the producer and the consumer. This decoupling enables a more agile landscape
                     of evolving products and product users in general, and one of the aspects is that
                     producers and consumers can evolve their products individually, based on their needs
                     and timelines.
                  </p>
                  <p>With API products and their consumers changing individually, it is important to have
                     a well-defined and documented process how changes in the API are communicated and
                     engineered. The goal is to balance two factors. One factor is the ease of consumption
                     so that consumers do not have to worry about their products being disrupted because
                     an API they are using is changing and breaking it. The second factor is the ease of
                     production where the API product owners want to be able to evolve their product, without
                     having to coordinate with all consumers of the API, and having to wait for them to
                     make changes.
                  </p>
                  <p>There are different ways how this goal can be achieved, and picking one of them depends
                     on the value that is assigned to making changes work for every single consumer, and
                     making it easier for the API product team to evolve their API when necessary.
                  </p>
               </text>
            </p><button class="accordion" title="Design APIs so that they can evolve without breaking API consumers.">Designing for Evolution</button><div class="panel">
               <p>
                  <text>
                     <p>One possible way to handle change management is to design extensibility into the API
                        itself. By using extensible design, changes to the API can take advantage of this
                        extensibility, and existing consumers can continue to use the API without having to
                        adjust.
                     </p>
                     <p>The specific design depends on the API style and technology, and on the intended extensibility.
                        Regardless of the style and technology, design options will usually fall between these
                        two extremes:
                     </p>
                     <ul>
                        <li>No extensibility is the easiest design and allows consumers to fully rely on the API
                           as it is when they write their code. However, with this design option there is no
                           extensibility at all, making it impossible for the API producer to make any changes
                           to the API without breaking existing consumers.
                        </li>
                        <li>Unlimited extensibility is the hardest design and allows producers to change everything
                           in the API, allowing them unconstrained changes to the API. However, with this design
                           option it becomes hard for consumers to fully implement support for all possible extensions,
                           making it hard for consumers to use the API.
                        </li>
                     </ul>
                     <p>In practice, most extensibility designs fall somewhere in the middle between these
                        options, trying to strike a balance between allowing some extensibility, while still
                        making it relatively easy to consume the API without having to support a very complex
                        extensibility model. The patterns discussed in <cite ref="robust-extensibility"></cite> are one possible way to design for evolution.
                     </p>
                  </text>
               </p><button class="accordion" title="Allow extensions but always make it safe to ignore them.">Must Ignore Semantics</button><div class="panel">
                  <p>
                     <text>
                        <p>One relatively simple way to allow extensions is to always make it safe to ignore
                           them. This means that anything any consumer will depend on will always be there, and
                           it will never change its meaning. In practice, this often breaks down to the following
                           strategies:
                        </p>
                        <ul>
                           <li>Once something is defined or added, it must stay defined. The only slight exception
                              for this is if something is optional: This means that it may or may not appear. This
                              means that changes to the API might make this required, or not support it any more.
                              Both are specializations of something being optional, so this is acceptable.
                           </li>
                           <li>Clearly indicate where extensions may appear, this makes it possible for consumers
                              to write code that will not break when something new shows up.
                           </li>
                           <li>Make it safe to ignore any extension, by only defining extensions that can be safely
                              ignored without compromising current API consumers.
                           </li>
                        </ul>
                        <p>By following this strategy, it is relatively easy to define an API that evolves in
                           a monotonic way: It only grows, and nothing is ever removed. This is also known as
                           the "Robustness Principle" <cite ref="rfc1122"></cite> that asks to "be liberal in what you accept, and conservative in what you send".
                        </p>
                     </text>
                  </p>
               </div>
            </div><button class="accordion" title="Never change released APIs and operate as many versions in parallel as required.">Immutable API Versions</button><div class="panel">
               <p>
                  <text>
                     <p></p>
                  </text>
               </p><button class="accordion" title="Manage releases automatically to operate many versions in parallel and route users to their versions.">Automated Release Versioning</button><div class="panel">
                  <p>
                     <text>
                        <p></p>
                     </text>
                  </p>
               </div>
            </div>
         </div><button class="accordion" title="Why does the API exist?">Documenting API Motivation</button><div class="panel">
            <p>
               <text>
                  <p></p>
               </text>
            </p><button class="accordion" title="Fundamental and existing capabilities in organizations can be exposed through APIs.">Inward-Out APIs Exposing Existing Capabilities</button><div class="panel">
               <p>
                  <text>
                     <p></p>
                  </text>
               </p><button class="accordion" title="">Encapsulating Existing Capabilities</button><div class="panel">
                  <p>
                     <text>
                        <p></p>
                     </text>
                  </p>
               </div>
            </div><button class="accordion" title="">Outward-In APIs Designed to Satisfy Consumers</button><div class="panel">
               <p>
                  <text>
                     <p></p>
                  </text>
               </p><button class="accordion" title="">Product as API</button><div class="panel">
                  <p>
                     <text>
                        <p></p>
                     </text>
                  </p>
               </div>
            </div>
         </div><button class="accordion" title="Make error messages easy to understand and provide information how to fix problems.">Meaningful Error Messages</button><div class="panel">
            <p>
               <text>
                  <p>Most APIs use styles where things can go wrong. The more helpful an API is in explaining
                     what went wrong, and how a developer or user might be able to address the problem,
                     the more easy the API is to use.
                  </p>
                  <p>It is important to keep in mind that in case of error messages, a better Developer
                     Experience (DX) with more helpful and clearly structured error messages directly translates
                     into the possibility to create a better User Experience (UX). If the API only produces
                     one generic error messages, that is the only thing that an application can display
                     to the user. If, on the other hand, the error message is descriptive and machine-understandable,
                     applications can at the very least display more meaningful error messages, and ideally
                     even implement behavior that mitigates the effects of the error.
                  </p>
               </text>
            </p><button class="accordion" title="Use expressive and standardized error formats across APIs.">Standard Error Format</button><div class="panel">
               <p>
                  <text>
                     <p>Error messages benefit from using a shared structure that can be used across various
                        APIs. The structure should define the most important aspects of error messages across
                        APIs, and should also allow extensions so that individual APIs can extend the error
                        messages with additional details. Using a standardized error format has two main advantages.
                     </p>
                     <p>The first advantage is that it makes it easier for developers and humans to work with
                        various APIs. It is only necessary to understand the error message format one time,
                        and then this understanding works across all APIs. Error messages still can be made
                        very expressive and rich by adding details through the format's extension mechanism.
                     </p>
                     <p>The second advantage is that it becomes possible to build tooling around the format.
                        One form of tooling can be libraries that make it easier foe developers to produce
                        or consume error messages. Another form of tooling is that it becomes much easier
                        to observe error messages across the entire API landscape, making it relatively easy
                        to build tooling that consumes and analyzes error messages for an entire API landscape.
                     </p>
                  </text>
               </p><button class="accordion" title="For JSON and XML error messages, RFC 7807 provides a standardized and extensible error format.">Use RFC 7807 HTTP Problem Reports</button><div class="panel">
                  <p>
                     <text>
                        <p>The Internet standard <cite ref="rfc7807"></cite> defines a model for error messages for HTTP APIs. It is based on the assumption that
                           the API is resource-oriented, and that the error message thus is a result of the standard
                           HTTP model of interacting with resources: A client sends a request to a resource,
                           and 
                        </p>
                     </text>
                  </p>
               </div>
            </div>
         </div><button class="accordion" title="Methods of adding asynchronous notifications to APIs that are primarily using a request/response style.">Notifications in Request/Response APIs</button><div class="panel">
            <p>
               <text>
                  <p>Many API styles are focused on request/response interaction patterns: The API provides
                     a service that is invoked by a client and then produces a response that the client
                     consumes and processes. This pattern underlies the major API styles such as RPC, URI,
                     REST, and query-based. In all these styles, clients send requests that are processed
                     on the server-side.
                  </p>
                  <p>However, it is possible that clients want to be notified when something happens on
                     the server side. Typical examples for this are state changes on the server side, where
                     clients may be interested to learn about state changes of resources they are interested
                     in. Implementing this functionality in a pure request/response interaction pattern
                     can be wasteful, because clients then need to keep polling the server, wasting bandwidth
                     and server resources.
                  </p>
                  <p>In terms of interaction patterns, it would be better so implement this with a notification
                     that is initiated by the server. For this to work, this requires some sort of subscription
                     mechanism where a client declares interest in a (set of) published resources, so that
                     notifications can be delivered to the subscribed clients. This general pattern is
                     called Publish/Subscribe (PubSub), and can be implemented in a variety of ways.
                  </p>
               </text>
            </p><button class="accordion" title="Services individually support and manage subscriptions to notifications.">Service Subscription Support</button><div class="panel">
               <p>
                  <text>
                     <p></p>
                  </text>
               </p><button class="accordion" title="WebSocket is a protocol originally designed to support a persistent channel between a server and a browser.">Use the WebSocket protocol for server/client communications</button><div class="panel">
                  <p>
                     <text>
                        <p>WebSocket <cite ref="rfc6455"></cite> was originally designed to provide a persistent channel between a browser-based Web
                           app and a server. As the name implies, the protocol creates a simple communications
                           channel that can be used to exchange any kind of information between a server and
                           a client.
                        </p>
                        <p>Defining notification mechanisms with WebSocket is a bit challenging because it does
                           not support any PubSub functionality or any specific way how to represent and exchange
                           notifications. This means that for using WebSockets as a notification channel, there
                           must be a well defined model for how to subscribe to specific notifications, and how
                           these notifications will be represented and delivered.
                        </p>
                     </text>
                  </p>
               </div><button class="accordion" title="WebSub is a protocol supporting a subscription and a delivery mechanism for information feeds.">Use the WebSub protocol for server/client communications</button><div class="panel">
                  <p>
                     <text>
                        <p>WebSub <cite ref="websub"></cite> was originally known under the name PubSubHubbub. It started as a mechanism to support
                           subscriptions to feeds, so that feed updates could be pushed to subscribers instead
                           of subscribers having to pull the feed to check for updates. WebSub includes a mechanism
                           for advertising WebSub hubs, subscribing to hubs by registering callbacks, and delivering
                           updates to subscribers.
                        </p>
                        <p>The older version PubSubHubbub used the Atom format <cite ref="rfc4287"></cite> for protocol messages, but the newer WebSub specification does not prescribe a specific
                           message format. It simply defines how messages of different types are interchanged
                           to implement the subscription and delivery functionality. This means that when using
                           WebSub, it is necessary to be specific about the message formats being used.
                        </p>
                     </text>
                  </p>
               </div><button class="accordion" title="Webhooks use HTTP communications but reverse the typical client/server roles.">Webhooks</button><div class="panel">
                  <p>
                     <text>
                        <p>Webhooks are an implementation pattern that is based on callbacks and allows the reverse
                           of the typical client/server control flow in Web-based interactions. The pattern is
                           based on registering a callback, which is then used by the server to notify the client
                           when events happen. This means that for the Webhooks pattern, the typical client/server
                           roles in Web-based interactions get reversed: The event triggers the server to call
                           the callback. Because of this reversed control flow, Webhooks are useful to avoid
                           polling and allow consumers to be notified of events when they happen.
                        </p>
                        <p>While the fundamental idea of Webhooks is easy, the model leaves many questions of
                           a PubSub mechanism open. Making callbacks reachable can be compromised by network
                           security mechanisms. It is easy to overwhelm services with too many subscription requests.
                           It is not defined how often and for how long callbacks should be repeatedly attempted
                           when there are delivery problems. The exact protocol of the notification mechanism
                           (how to represent notifications and how to use HTTP mechanisms for richer communications)
                           is not clearly defined.
                        </p>
                     </text>
                  </p>
               </div>
            </div><button class="accordion" title="Notification support as part of the API platform with a dedicated event-driven messaging infrastructure.">Using a Messaging Platform</button><div class="panel">
               <p>
                  <text>
                     <p>For notifications not using the request/response pattern, it is possible to use a
                        messaging platform that allows servers to send their notifications, and allows clients
                        to receive these notifications. There are a variety of possible messaging platforms
                        that can be used for this scenario, and depending on the messaging platform, there
                        may be different models of how to subscribe to notifications, and how these notifications
                        are delivered via the messaging platform.
                     </p>
                  </text>
               </p><button class="accordion" title="Kafka provides access to sequence of topic-identified messages.">Kafka as a Distributed Commit Log</button><div class="panel">
                  <p>
                     <text>
                        <p></p>
                     </text>
                  </p>
               </div><button class="accordion" title="RabbitMQ allows clients to consume messages from a managed message queue.">RabbitMQ as a Message Broker</button><div class="panel">
                  <p>
                     <text>
                        <p></p>
                     </text>
                  </p>
               </div>
            </div>
         </div><button class="accordion" title="Provide machine-readable descriptions of APIs for tooling and automation.">Provide Service Descriptions</button><div class="panel">
            <p>
               <text>
                  <p>...</p>
               </text>
            </p><button class="accordion" title="For APIs following the resource-oriented API style, use OpenAPI to describe the individual resource URIs.">Provide OpenAPI Descriptions for Resource-Oriented APIs</button><div class="panel">
               <p>
                  <text>
                     <p>...</p>
                  </text>
               </p><button class="accordion" title="Swagger UI is a tool that can be used to design, discuss, and test APIs in an API-first style.">Use Swagger UI Descriptions</button><div class="panel">
                  <p>
                     <text>
                        <p>...</p>
                     </text>
                  </p>
               </div>
            </div>
         </div><button class="accordion" title="Provide service documentation that is appropriate for the maturity of the API and the intended audience.">Provide Service Documentation</button><div class="panel">
            <p>
               <text>
                  <p>...</p>
               </text>
            </p><button class="accordion" title="...">Use OpenAPI Descriptions for Resource-Oriented APIs</button><div class="panel">
               <p>
                  <text>
                     <p>...</p>
                  </text>
               </p><button class="accordion" title="...">Use Swagger UI Documentation</button><div class="panel">
                  <p>
                     <text>
                        <p>...</p>
                     </text>
                  </p>
               </div>
            </div>
         </div><button class="accordion" title="Timestamps are a popular data type and should be used in a robust and widely-supported way.">Using Timestamps</button><div class="panel">
            <p>
               <text>
                  <p>Timestamps (combining date and time information, sometimes allowing data-only formats
                     as well) are a popular data type in APIs. However, representing these timestamps is
                     not trivial, as date and time information is influenced by aspects such as timezones,
                     daylight savings settings, and reference points for dates and times.
                  </p>
                  <p>It therefore makes sense to use existing formats for timestamps that handle the complexities
                     of date and time representation in well-defined ways. By using consistently using
                     existing formats, it also becomes easier for developers to use libraries that allow
                     them to handle timestamps easily and reliably.
                  </p>
               </text>
            </p><button class="accordion" title="RFC 3339 is a robust and widely used format for timestamps on the Internet.">Use RFC 3339 Timestamps</button><div class="panel">
               <p>
                  <text>
                     <p><cite ref="rfc3339"></cite></p>
                  </text>
               </p><button class="accordion" title="Convert timestamps to RFC 3339 when they are used in the context of APIs.">Convert Timestamps to RFC 3339</button><div class="panel">
                  <p>
                     <text>
                        <p>...</p>
                     </text>
                  </p>
               </div>
            </div>
         </div>
      </ol><script>
var acc = document.getElementsByClassName("accordion");
var i;

for (i = 0; i < acc.length; i++) {
acc[i].addEventListener("click", function() {
this.classList.toggle("active");
var panel = this.nextElementSibling;
if (panel.style.maxHeight) {
panel.style.maxHeight = null;
} else {
panel.style.maxHeight = panel.scrollHeight + "px"; } }); }
          </script></body>
</html>